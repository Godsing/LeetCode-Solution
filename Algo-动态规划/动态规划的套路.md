

动态规划，本质上就是一种用空间换时间的做法，通过把中间过程的一些值记录下来，免得重新计算。

动态规划和备忘录法，其实差不多，如果非要严格区分的话，那可以说动态规划是自底向上的，而备忘录法是自顶向下的。

PS：其实不用去考虑什么“最优子结构”、“无后效性”等等。因为，对于最优化问题的求解，当你能找到子问题，并且定义出状态及其转移方程后，自然而然就说明了该问题已经满足了“无后效性”和“最优子结构”了。



## 运用方法

1. **找到 base case**：不需要计算就能得到解；
   
1. **找到子问题**：考虑 base case 和常规 case 间的差异，找到子问题；
   
   1. 由 N 个子问题从小到大递推到原问题，一维的，也就是说分阶段的；
   2. 由 $N^2$ 个子问题从小到大递推到原问题，这是二维的（二维张量，即**需要两个索引才能唯一定位到某个子问题**），并不是分阶段的；e.g. Interleaving String, 力扣第 188 题「 [买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)」
   3. 由 $N^3$ 个子问题从小到大递推到原问题，这是三维的，也不是分阶段的；
   4. 可能有更高的维度的，以此类推……
   
   $N^x$ 个子问题，那么 dp 数组便是 x 维张量，即需要 x 个索引才能定位到特定的子问题。
   
3. **为每个子问题，定义 k 个状态**：可以直接是子问题的解，或者可以据此 k 个状态求得子问题的解。

   如果直接定义状态为子问题的最优解能找到合适的状态转移方程，那就这么定义。否则可能就需要考虑定义一些间接值以便进行状态转移。

   例如，力扣第 188 题「 [买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)」，需要定义 2 个状态：当前持有股票的收益、当前不持股的收益。

4. 明确子问题/阶段间存在哪些选择/连接，即明确哪些子问题可以演进到当前子问题，并以此**确定状态转移方程**。可以这么问自己：

   - 子问题在某一维度上规模加一时，如何根据 已计算好的子问题的状态 递推计算 新的子问题的状态？
   - 或者：当前子问题的状态，如何由之前计算好的子问题们计算(选择)得到？eg. 72. Edit Distance

   1. 这时候可能需要从一个(或几个，这时可能需要决策) 已经计算好的子问题的状态 递推得到；
   2. 也可能需要从 O(N) 数量的 已解决子问题的状态 递推得到。（这时可能需要决策）

5. **自底向上计算状态**，求得所有子问题的状态。原问题的状态，可能就是解，也可能只是间接值，还需要做点简单的计算。



比喻：dp 数组就像是一堆整齐排列的箱子，每个箱子(对应一个子问题)里可以放若干个数(状态)，箱子间具有一定的联系，某些箱子中的数，可以觉得接下来某个箱子中的数。当然，除了迭代+dp数组的方法，也可以用递归+备忘录的方法。



## 股票买卖问题套路

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems





## 参考资料

- [经典动态规划：0-1 背包问题](https://labuladong.gitee.io/algo/3/26/84/)
- [经典动态规划：子集背包问题](https://labuladong.gitee.io/algo/3/26/85/)

