

## 示例问题

以[剑指 Offer II 015. 字符串中的所有变位词](https://leetcode-cn.com/problems/VabMRr/)为例进行说明。

给定两个字符串 s 和 p，找到 s 中所有 p 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

变位词 指字母相同，但排列不同的字符串。

 

示例 1:

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的变位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的变位词。
```

示例 2:

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的变位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的变位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的变位词。
```

**提示:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` 和 `p` 仅包含小写字母



## 代码框架

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        // 记录解
        vector<int> res;
        // 当前窗口状态
        // 目标
        // 左右指针
        int left = 0, right = 0;

        // 滑动窗口算法
        while (right < s.size()) {
            // 挪动右指针
            char rch = s[right];
            right++;
            // 更新当前窗口状态
            // 判断是否达到目标
            while (right - left >= p.size()) {  // 注意，此时窗口是[left, right)
                // 挪动左指针
                char lch = s[left];
                left++;
                // 更新当前窗口状态
            }
        }
        return res;
    }
};
```

具体实现：

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        // 记录解
        vector<int> res;
        // 当前窗口状态：所需字母及其个数、已满足条件的字母数
        unordered_map<char, int> required;
        for (char ch : p) required[ch]++;
        int satisfied = 0;
        // 目标：需要满足条件的字母数 
        int target = required.size();
        // 左右指针
        int left = 0, right = 0;
        // 滑动窗口算法
        while (right < s.size()) {
            // 挪动右指针
            char rch = s[right];
            right++;
            // 更新当前窗口状态
            required[rch]--;
            if (required[rch] == 0) satisfied++;
            // 判断是否达到目标
            if (satisfied == target) res.push_back(left);
            // 注意，此时窗口是[left, right)
            while (right - left >= p.size()) {
                // 挪动左指针
                char lch = s[left];
                left++;
                // 更新当前窗口状态
                if (required[lch] == 0) satisfied--;
                required[lch]++;
            }
        }
        return res;
    }
};
```





## Debug&Learning



