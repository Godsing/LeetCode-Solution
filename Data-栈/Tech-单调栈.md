## 单调栈技巧

> 用于这种技巧的适用面并不广，因此没把它拎出来作为一个单独的文件夹。

栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。

单调栈，实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。

听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element，本文教你用单调队列的算法模版解决这类问题。



### 题目

现在给你出这么一道题：

给你一个数组 `nums`，请你返回一个等长的结果数组，结果数组中存储着比“该索引位置的原始元素”更大的下一个元素的值，如果没有更大的元素，就存 -1。

函数签名如下：

```java
int[] nextGreaterElement(int[] nums);
```

比如说，输入一个数组 `nums = [2,1,2,4,3]`，你返回数组 `[4,2,4,-1,-1]`。



### 题解

这道题的暴力解法很好想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是 `O(n^2)`。

这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的 Next Greater Number 呢？

很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。

![img](https://mdpicbed.oss-cn-hongkong.aliyuncs.com/imgs/1.jpeg)

这个情景很好理解吧？带着这个抽象的情景，先来看下代码。

```java
int[] nextGreaterElements(int[] nums) {
    int[] res = new int[nums.length];  // 存放答案的数组
    Stack<Integer> s = new Stack<>();
    for (int i = nums.length - 1; i >= 0; i--) {  // 从后往前遍历
        // 身后那些没比我(nums[i])高的，反正会被挡住，都可以走了...
        while (!s.isEmpty() && s.peek() <= nums[i]) {
            s.pop();
        }  // 剩下的人，站得越靠前的越矮（结果就是，栈顶到栈底，元素值严格单调递增）
        // 剩下的人中的第一个，就是我(nums[i])身后第一个比我高的人(next great number)
        res[i] = s.isEmpty() ? -1 : s.peek();
        s.push(nums[i]);
    }
    return res;
}
```

> 这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。
>
> 这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 `O(n^2)`，但是实际上这个算法的复杂度只有 `O(n)`。
>
> 分析它的时间复杂度，要从整体来看：总共有 `n` 个元素，每个元素都被 `push` 入栈了一次，而最多会被 `pop` 一次，没有任何冗余操作。所以总的计算规模是和元素规模 `n` 成正比的，也就是 `O(n)` 的复杂度。

