## 题目

此题同《318. 最大单词长度乘积》，考察的是字符串、集合运算、位运算等知识。



## 题解

假设我们将所有单词的长度，记为一个整数数组，长度为 N，要找到最大的那个“两数乘积”，没有什么比较快的算法，时间复杂度是 $O(N^2)$。

这已经是很高的时间复杂度了，因此，对于这道题，就要求我们必须以很低的时间复杂度来判断两个单词是否有字符交集。

可是，对于采用哈希表存储结构的集合 A、B，要判断他们的交集，时间复杂度至少是 $O(min(size(A), size(B)))$. 

这两个时间复杂度再相乘，实在太高了。那么，有没有办法加速“单词字符是否存在交集”的判定呢？

考虑到，这里的单词只有小写字母，而小写字母只有26个，我们能否用一个比特，来表示每个字母的存在与否？进而，可否用一个32位的无符号整数，来表示某个单词都包含哪些字母？再进一步，可否用两个整数的“按位与”运算，来判断两个单词的字母是否存在交集呢？

答案是肯定的。

基于上述思路，整理代码如下：

```c++
class Solution {
public:
    int maxProduct(vector<string>& words) {
        //由于字符串中只包含英文小写字母，只有 26 个，因此可以用 32 位的 int 来存储每一个字母是否在字符串中出现
        //通过 int 的位运算“与”，来判断两个字符串是否有交集即可
        vector<int> nums(words.size());  //一次性分配空间，而不是逐次 push_back，提升了效率
        for (int i=0; i < words.size(); i++) {
            int num = 0;
            for (const char& c: words[i]) {
                num |= 1 << (c - 'a');
            }
            nums[i] = num;
        }
        //遍历所有可能的组合，找到最大的乘积
        int result = 0;
        for (int i = 0; i < words.size(); i++) {
            for (int j = 0; j < words.size(); j++) {
                if ((nums[i] & nums[j]) == 0)  //取消使用 continue，提升效率
                    result = max(result, int(words[i].size() * words[j].size()));
            }
        }
        return result;
    }
};
```



## 总结

1. 可以用整数的“按位与”运算，来实现集合的交集运算，将时间复杂度将至 $O(1)$；
2. 可以用整数的“按位或”运算，来实现集合的并集运算，将时间复杂度将至 $O(1)$；

