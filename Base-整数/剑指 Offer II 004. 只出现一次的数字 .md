## 题目

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

 

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

 

**提示：**

- `1 <= nums.length <= 3 * 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**

 

**进阶：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？



注意：本题与主站 137 题相同：https://leetcode-cn.com/problems/single-number-ii/

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/WGki4K

## 题解

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        //将每个数字用二进制表示，看作一个定长(sizeof(int))的 bit 数组
        //若不考虑只出现一次的元素，统计所有其他 bit 数组，那么最终每个位置出现的 0或1 的次数，将是 3 的倍数
        //假设 sizeof(int) 为 32，那么我们可以用 32 个数字，来统计 32 个 bit 位出现的 1 的个数
        //最终遍历这 32 个统计值，对于每个统计值，若为 3 的倍数，说明只出现一次的数字对应 bit 位为 0，否则为 1
        //倘若，我们想再进一步优化，可以这么考虑：因为数组中每个元素至多出现 3 次，因此每个元素的每个 bit 至多重复 3 次
        //那么，我们如果将每个 bit 位置的值累加到一个三进制的数字里，由于逢三进一，把进位去掉
        //最终，每个 bit 位置累加后的三进制的值将必然是 0 或 1，而这些 0、1，就是只出现一次的元素的每个 bit
        //由于三进制数可以有两位二进制来表示，所以原本我们需要一个长度 32 的三进制数数组
        //现在可以将其拆开为两个长度 32 的二进制数组，一个表示低位，一个表示高位，而每个数组，其实就是一个 int 变量
        //那么重点就变成，用两个二进制数来实现三进制，不过这很简单，只需依照这个规则进位：00->01->10->00
        //即二进制 10 表示三进制中的 2，再加 1，就会产生进位，抛弃进位后，就变成 00 了。
        //不过话说回来，要实现这个进位，如果不了解卡诺图化简，“通过位运算来实现进位”的方法不是很好想出来。
        //而且，这种做法，可以拓展到任意情况：除了一个只出现一次，其他都出现 N 次的，实现一个 N 进制就可以了。
        int b0=0, b1=0;
        for (int num: nums) {
            b0 = (num ^ b0) & (~b1);
            b1 = (num ^ b1) & (~b0);
        }
        return b0;
    }
};
```



**思路：**

用一个长度为32的数组，数组中每个元素是三进制数，用它来统计`int`的每一个二进制位置中`1`出现的次数，逢3进位，但进位会被丢弃，那么最终数组元素的值必定为0或1，将这些0或1凑成一个`int`类型的数字，便是解。



**具体步骤：**

1. 用两个比特来存储该3进制数，那么可以写出真值表：(二进制加法：$ba_2 + n = BA_2$)

| b    | a    | n    | B    | A    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    |
| 0    | 0    | 1    | 0    | 1    |
| 0    | 1    | 0    | 0    | 1    |
| 0    | 1    | 1    | 1    | 0    |
| 1    | 0    | 0    | 1    | 0    |
| 1    | 0    | 1    | 0    | 0    |

2. 由真值表写出逻辑表达式：
   1. A = b'a'n + b'an' = **b'(a^n)**
   2. B 有两种写法：
      - B = b'an + ba'n'
      - B = b'A'n + bA'n' = **A'(b^n)**



PS. 也可以采用卡诺图化简，只是这里比较简单，就没必要了。



**参考资料：**

- [数字电路学习笔记（五）：逻辑设计基础-真值表、表达式、卡诺图](https://zhuanlan.zhihu.com/p/83106691)

