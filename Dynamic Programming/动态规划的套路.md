【个人小总结】

设问题规模为N

1. 找到子问题，那么可能：

   1. 由 N 个子问题从小到大递推到原问题，一维的，也就是说分阶段的；
   2. 由 N^2 个子问题从小到大递推到原问题，这是二维的，并不是分阶段的；eg. Interleaving String
   3. 由 N^3 个子问题从小到大递推到原问题，这是三维的，也不是分阶段的；
   4. 可能有更高的维度的，以此类推……

   另外，通过推测子问题的维度，可以提示下一步定义的状态该有几个维度。

2. 为子问题定义状态，常见的套路是：

   1. 由所要求解的目标直接定义状态，这时候状态值相当于就是子问题的最优解；
   2. 定义一些状态，这些状态可以计算得到子问题的最优解；
   3. 有 O(N) 个点，为每个点定义一个或几个状态，由该 O(N) 个点可以找出当前子问题的最优解；

   具体用那种套路，主要是看第三步；如果直接定义状态为子问题的最优解能找到合适的状态转移方程，那就这么定义，否则可能就需要考虑一下定义一些中间的状态以便进行状态转移。

3. 找到状态转移方程，可以这么问：

   - 子问题在某一维度上规模加一时，如何根据 已计算好的子问题的状态 递推计算 新的子问题的状态？
   - 或者：当前子问题的状态，如何由之前计算好的子问题们计算(选择)得到？eg. 72. Edit Distance

   1. 这时候可能需要从一个(或几个，这时可能需要决策) 已经计算好的子问题的状态 递推得到；
   2. 也可能需要从O(N)数量的 已解决子问题的状态 递推得到。（这时可能需要决策）

自底向上计算状态，最终的状态可能就是所要求解的目标，或者进行进一步的简单计算（视如何定义状态而定）。

