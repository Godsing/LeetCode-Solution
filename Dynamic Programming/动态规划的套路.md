

## 什么时候用？

对于最优化问题，先尝试用暴力解法，然后考虑其中是否存在重叠子问题可以减少计算量。

动态规划，本质上就是一种用空间换时间的做法，通过把中间过程的一些值记录下来，免得重新计算。

动态规划和备忘录法，其实差不多，如果非要严格区分的话，那可以说动态规划是自底向上的，而备忘录法是自顶向下的。

PS：其实不用去考虑什么“最优子结构”、“无后效性”等等。因为，对于最优化问题的求解，当你能找到子问题，并且定义出状态及其转移方程后，自然而然就说明了该问题已经满足了“无后效性”和“最优子结构”了。



## 如何运用？(具体步骤)

设问题规模为N，然后进行如下几个步骤：

1. 找到**子问题**。常见的存在这么几种可能：

   1. 由 N 个子问题从小到大递推到原问题，一维的，也就是说分阶段的；
   2. 由 $N^2$ 个子问题从小到大递推到原问题，这是二维的，并不是分阶段的；e.g. Interleaving String
   3. 由 $N^3$ 个子问题从小到大递推到原问题，这是三维的，也不是分阶段的；
   4. 可能有更高的维度的，以此类推……

   另外，通过推测子问题的维度，可以提示下一步定义的状态该有几个维度。

2. 为子问题**定义状态**，常见的套路是：

   1. 由所要求解的目标直接定义状态，这时候状态值相当于就是子问题的最优解；
   2. 定义一些状态，这些状态可以计算得到子问题的最优解；
   3. 有 O(N) 个点，为每个点定义一个或几个状态，由该 O(N) 个点可以找出当前子问题的最优解；

   具体用那种套路，需要同时考虑下文的第3步：如果直接定义状态为子问题的最优解能找到合适的状态转移方程，那就这么定义，否则可能就需要考虑一下定义一些中间的状态以便进行状态转移。

3. 找到**状态转移方程**，可以这么问：

   - 子问题在某一维度上规模加一时，如何根据 已计算好的子问题的状态 递推计算 新的子问题的状态？
   - 或者：当前子问题的状态，如何由之前计算好的子问题们计算(选择)得到？eg. 72. Edit Distance

   1. 这时候可能需要从一个(或几个，这时可能需要决策) 已经计算好的子问题的状态 递推得到；
   2. 也可能需要从 O(N) 数量的 已解决子问题的状态 递推得到。（这时可能需要决策）

自底向上计算状态，最终的状态可能就是所要求解的目标，或者进行进一步的简单计算（视如何定义状态而定）。

